#!/usr/bin/env parser
## комментарии начининаются с символов ## или #! и следуют до конца строки
## все символы комментариев полностью игнорируются 
## включая также завершающий \

## пустые строки также игнорируются

## числовые константы:
67	## целое
0x18	## целое в шестнадцатиричном виде
056	## целое в восьмиричном виде
-11 -062 -0x11fe ## целые со знаком

#####
0.34	## дробное с фикс. запятой
1.2E+2	## дробное с плавающей запятой
-652.765 -255.11E-12 ## дробные со знаком


#! строковые константы
'это константа'
'esc-символы C : \r \n \t \v \b \f \a \e'
'маскирование символов языка \\ \" \{ \} \[ \] \''
'ascii коды символов: \033 \x1f \45'
'или устоявшиеся имена: \&ESC; \&amp;'

#! программа состоит из выражений
expression
expression2 ; expression3 	## выражения разделяются ; или \n

#! каждое выражение состоит из слов разделяемых пробелами
word
word2 	word3

#! первое слово выражения интерпретируются как имя исполняемой команды, остальные - как её аргументы
command arg1 arg2; command2 1 2 3
command3 arg arg arg

#?>При интерпретации
этот текст будет выведен
как есть на консоль<?#

#! выражения группируются в блоки-списки заключенные в {}
this is a list {
	one two
	3 4
}
#! списки могут быть вложенными
nested lists are { 1 2
  3 4 { nested a b }
}

#! макросы начинаются с символа #
#! в качестве аргументов им передаются слова выражения как текст
#! макросы раскрываются от конца выражения к началу (справа налево)
command whith #macro subcommand arg #! в #macro будут переданны аргументы 'subcommand' 'arg'


#! переменные
$varname		## подстановка значения переменной
$varname(index) 	## подстановка значения элемента массива
$varname(index index2) ## массивы могут быть многоуровневыми
$(varname)		## допустимая форма
$(varname index)	## также допустимо

## имена самих переменных могут передаваться через другие переменные
$$varname
$($varname(index) index2)


## подстановка команд
set x(i) [ command arg arg2 ]
[ get x(i) ]		## аналог $x(i)
[ get x i ]		##

set foo [ func { arg1 arg2 argN } { body } curry1 curry2 ]
proc foo {arg1 arg2 argN} { body } curry1 curry2

foreach {a b} {1 2 3 4 5 6 7 8 9 10} {
	echo $_ 	#! {1 2} {3 4} ...
	echo $a		#! {1} {3}
}

